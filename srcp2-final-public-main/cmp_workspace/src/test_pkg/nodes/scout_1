#!/usr/bin/env python3

# Authors: Hongik #

import math
import os
import select
import sys

import rospy
import rosservice
import tf
import time
import ctypes
import struct
import tf2_ros
import imutils

# import pcl

# from ._pcl import *
from geometry_msgs.msg import Point, Pose, Quaternion, Twist, PoseWithCovarianceStamped, PoseStamped
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan, Imu, Image, PointCloud2, PointField, JointState
from srcp2_msgs.msg import VolSensorMsg, SystemMonitorMsg, ScoreMsg
from std_msgs.msg import Float64, Int32
from tf.transformations import euler_from_quaternion
# from darknet_ros_msgs.msg import BoundingBoxes

import sensor_msgs.point_cloud2 as pc2
import numpy as np
import numpy.linalg as lin

import cv2
from darknet_ros_msgs.msg import BoundingBoxes
from cv_bridge import CvBridge, CvBridgeError

if os.name == 'nt':
    import msvcrt
else:
    import tty, termios

team_state = 0
team_state_pub = rospy.Publisher("team_1/state", Int32, queue_size=1)
image_pub = rospy.Publisher('team_1/image_raw', Image, queue_size=10)

Robot_tag = "S1) "
LINEAR_VEL = 0.22
STOP_DISTANCE = 4.0
STOP_DISTANCE_YOLO = 5.0
LIDAR_ERROR = 0.1
err_code = 0
get_pose = True
# get_pose = False

station_center, station_y_center, station_width, station_height, station_y, station_x = 0, 0, 0, 0, 0, 0
frame, cal_x, cal_y, distance, center, width_raw, height_kf, slam_check, center_check = 0, 0, 0, 0, 0, 0, 0, 0, 0
image_topic = '/small_scout_1/camera/left/image_raw'

SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR
pub = rospy.Publisher('small_scout_1/skid_cmd_vel', Twist, queue_size=10)
sensor_pitch = rospy.Publisher('small_scout_1/sensor/pitch/command/position', Float64, queue_size=10)
odom_pub = rospy.Publisher("odom", Odometry, queue_size=50)
scan_pub = rospy.Publisher("scan", LaserScan, queue_size=10)
PoseWithCovarianceStamped_pub = rospy.Publisher("initialpose", PoseWithCovarianceStamped, queue_size=50)
# rostopic pub /scout_1/sensor_controller/command std_msgs/Float64 "data: 0.5"

FR_pub = rospy.Publisher("small_scout_1/front_right_wheel/steer/command/position", Float64, queue_size=10)
FL_pub = rospy.Publisher("small_scout_1/front_left_wheel/steer/command/position", Float64, queue_size=10)
BR_pub = rospy.Publisher("small_scout_1/back_right_wheel/steer/command/position", Float64, queue_size=10)
BL_pub = rospy.Publisher("small_scout_1/back_left_wheel/steer/command/position", Float64, queue_size=10)

fl_vel_pub = rospy.Publisher('small_scout_1/front_left_wheel/drive/command/velocity', Float64, queue_size=10)
fr_vel_pub = rospy.Publisher('small_scout_1/front_right_wheel/drive/command/velocity', Float64, queue_size=10)
bl_vel_pub = rospy.Publisher('small_scout_1/back_left_wheel/drive/command/velocity', Float64, queue_size=10)
br_vel_pub = rospy.Publisher('small_scout_1/back_right_wheel/drive/command/velocity', Float64, queue_size=10)

state_pub = rospy.Publisher("rover_state/scout_1", ScoreMsg, queue_size=10)

vol_pub = rospy.Publisher("vol_arr/team_1", ScoreMsg, queue_size=10)

base_pub = rospy.Publisher("team_1/need_base", Int32, queue_size=10)


fr_float64 = Float64()
fl_float64 = Float64()
br_float64 = Float64()
bl_float64 = Float64()

F = 10
turn_ratio = 0.5

fl_vel = 0
fr_vel = 0
bl_vel = 0
br_vel = 0

light_data = 'high'  # stop / low / high
light_service_name = '/small_scout_1/spot_light'
light_srv_class = rosservice.get_service_class_by_name(light_service_name)
light_srv_client = rospy.ServiceProxy(light_service_name, light_srv_class)

settings = termios.tcgetattr(sys.stdin)
speed = math.pi * 1.5
tnspeed = 1
sigma = 4
goal_x = 0
goal_y = 0

power_health = 0
power_health_str = ""
power_level = 100
power_saver = False
battery_mode = 0
battery_mode_str = ""
power_rate = 0.0
solar_ok = 0

in_pit = False
need_base = False

roll = 0
pitch = 0
yaw = 0

start_y = 0.0
start_x = 0.0
start_z = 0.0
start_roll = 0.0
start_pitch = 0.0
start_yaw = 0.0

dt = 0.2
A = np.array([[1, dt], [0, 1]])
H = np.array([[1, 0]])
Q = np.array([[0.001, 0], [0, 0.01]])
R = 0.1
P = 3 * np.eye(2)
x_0 = 0.0
xp = 0.0
# xp2 = np.array([0, 0, 0])
xp2 = 0

xp_yaw, P_yaw, R_yaw = 0.0, 3 * np.eye(2), 0.1

call_step = 0

yaw = 0.0
yaw_d = 0.0
yaw_o = 0.0
center = 0.0
center_of_cmd_x = 0.0
width_raw = 0.0
width_kf = 0.0
distance = 0.0

base_x = -6.0
base_y = -6.0
base_z = 0.0

cal_x = 0.0
cal_y = 0.0
cal_x2 = 0.0
cal_y2 = 0.0
x_point = 0
y_point = 0
angle_point = np.zeros((360, 2))

########################

########################
angle_filter_size = 45
########################

########################
points = np.zeros((angle_filter_size, 2))
pitch_points = np.zeros((angle_filter_size, 1))

slam = False
slam_check = False
center_check = True
turn_to_goal = False
find_object = True

turn_circle = False

center_check_time = 0.0

goal_set = 45
goal = 1

goal_point = [
    [base_x, base_y],
    [8, -15],   # 1
    [0, -42],   # 2 (서쪽 start)

    [15, -35],  # 3     (1)
    [29, -20],  # 4     (1)
    [39, 0],    # 5     (1)

    [50, -7],   # 12    (2)
    [45, -28],  # 13    (2)
    [24, -50],  # 14    (2)
    [6, -61],   # 15    (2)

    [12, -76],  # 16    (3)
    [42, -64],  # 17    (3)
    [60, -38],  # 18    (3)
    [73, -6],   # 19    (3)
]


'''
goal_point = [
    [base_x, base_y],
    [8, -15],   # 1
    [0, -42],   # 2 (서쪽 start)

    [15, -35],  # 3     (1)
    [29, -20],  # 4     (1)
    [39, 0],    # 5     (1)
    [30, 22],   # 6     (1)
    [15, 36],   # 7     (1)
    [-2, 40],   # 8     (1)

    [2, 57],    # 9     (2)
    [24, 47],   # 10    (2)
    [43, 29],   # 11    (2)
    [50, -7],   # 12    (2)
    [45, -28],  # 13    (2)
    [24, -50],  # 14    (2)
    [6, -61],   # 15    (2)

    [12, -76],  # 16    (3)
    [42, -64],  # 17    (3)
    [60, -38],  # 18    (3)
    [73, -6],   # 19    (3)
    [61, 42],   # 20    (3)
    [36, 64],   # 21    (3)
    [2,  78],   # 22    (3)
]
'''
dt = 0.2
F = np.array([[1, 0, dt, 0], [0, 1, 0, dt], [0, 0, 1, 0], [0, 0, 0, 1]])
aX = 1
G = np.array([[(dt * dt) / 2, 0], [0, (dt * dt) / 2], [dt, 0], [0, dt]])  # 4*2
Qm = np.dot(np.dot(G, np.eye(2)), G.T)
g_Xs = np.zeros((4, 1))
g_Ps = np.eye(4)
g_Ps[0, 0] = 100
g_Ps[1, 1] = 100

before_score_time = rospy.Time(0)

base_center = 0
base_y_center = 0
base_rng = 0
base_y_rng = 0

rock_center = 0
rock_rng = 0
rock_y_center = 0
rock_y_rng = 0
rock_min = 0
rock_max = 0
rock_x_pose_min = 0
rock_x_pose_max = 0
rock_y_pose_min = 0
rock_y_pose_max = 0

v_index = 0
vol_center = 0
vol_y_center = 0
vol_type = ""
vol_rng = 0
pre_vol_type = ""
vol_index = 30
pre_vol_index = 0
vol_x = 0.0
vol_y = 0.0
vol_dis = 0.0
vol_stop = False
brake_data = 0.0
vol_point = np.zeros((28, 6))
# vol_type_array = np.empty((28, 1))
# vol_type_array.astype(np.string_)
vol_type_array = np.empty(28, dtype='<U16')
# numpy.empty(10, dtype='s256')

sensor_pitch_value = 10

print(vol_type_array.dtype)

hector_odom_x = 0.0
hector_odom_y = 0.0

odom_x = 0.0
odom_y = 0.0
odom_z = 0.0
odom_roll = 0.0
odom_pitch = 0.0
odom_yaw = 0.0

start_flag = 0

imu_yaw = 0.0
imu_pitch = 0.0
imu_init = True

far_from_base = [0.0, 0.0]

object_index = 0
object_distance = 0
base_distance = 0

object_x_center = 0
object_y_center = 0

object_x = 0.0
object_y = 0.0
object_z = 0.0

true_object_x = -26.24
true_object_y = 9.245
true_object_z = 15.585

true_base_x = 17.545
true_base_y = -5.46
true_base_z = 2.85

object_locate_index = 0.0
base_locate_index = 0.0
object_size = 0.0
base_size = 0.0

angle_default = 0.0
float64 = Float64()  # camera angle
float64.data = angle_default

marker_x_center = 0
marker_x_range = 0
marker_y_center = 0
marker_y_range = 0

find_object_time = 0.0

score = 0
calls = 0

pre_obs_base_y = 0
find_base_time = rospy.Time(0)
odom_yaw = 0.0
imu_init = True

bl_joint = 0.0
# gtg = False

h_1, h_2 = 0.0, 0.0
vol_dis_old, now_vol_dis, turn_count = 2.0, 0.0, 0

vol_center, vol_y_center, vol_width, vol_height, vol_x, vol_y = 0, 0, 0, 0, 0, 0


def box(data):
    try:
        global station_center, station_y_center, station_width, station_height, station_x, station_y, \
            base_center, base_y_center, base_rng, base_y_rng, center, \
            vol_center, vol_y_center, vol_width, vol_height, vol_x, vol_y

        station_center = 0
        station_y_center = 0
        vol_center = 0
        vol_y_center = 0
        vol_y = 0

        now_vol_min = 0

        for box in data.bounding_boxes:
            # print("box.id", box.id)

            if box.id == 0:  # 암석 장애물

                if box.ymax > now_vol_min:  # 가장 가까이 있는 암석 판별
                    vol_center = (box.xmax + box.xmin) / 2
                    vol_y_center = (box.ymax + box.ymin) / 2

                    vol_x = box.xmin
                    vol_y = box.ymax
                    vol_width = box.xmax - box.xmin
                    vol_height = box.ymax - box.ymin

            elif box.id == 1:
                station_center = (box.xmax + box.xmin) / 2
                station_y_center = (box.ymax + box.ymin) / 2

                station_x = box.xmin
                station_y = box.ymin
                station_width = box.xmax - box.xmin
                station_height = box.ymax - box.ymin
                base_center = (box.xmax + box.xmin) / 2
                base_rng = box.xmax - box.xmin
                base_y_center = (box.ymax + box.ymin) / 2
                base_y_rng = box.ymax - box.ymin
                center = base_center
                break

    except Exception as e:
        global err_code
        err_code = 4
        print("box except Error ", e)
        pass


def state_callback(data):
    try:
        global team_state, station_y_center
        # print("S1) team_state change ", data)
        team_state = data.data

        # if team_state > 3:
        #     saver_data = True  # stop / low / high
        #     saver_service_name = '/small_scout_1/system_monitor/power_saver'
        #     saver_srv_class = rosservice.get_service_class_by_name(saver_service_name)
        #     saver_srv_client = rospy.ServiceProxy(saver_service_name, saver_srv_class)
        #     saver_srv_client(saver_data)
        # else:
        #     saver_data = False  # stop / low / high
        #     saver_service_name = '/small_scout_1/system_monitor/power_saver'
        #     saver_srv_class = rosservice.get_service_class_by_name(saver_service_name)
        #     saver_srv_client = rospy.ServiceProxy(saver_service_name, saver_srv_class)
        #     saver_srv_client(saver_data)

    except Exception as e:
        global err_code
        err_code = 4
        print("state except Error ", e)
        pass


def image_callback(msg):
    try:
        global station_y, station_height, station_x, station_width, err_code, \
            base_center, base_y_center, base_rng, base_y_rng, cal_x, cal_y, base_distance, height_kf, h_1, h_2
        #        frame = frame + 1

        if team_state < 2:
            image_pub.publish(msg)
            # print("pub team1 image")

        #        if frame % 1 == 0:
        if base_center != 0:

            try:

                # Convert your ROS Image message to OpenCV2
                bridge = CvBridge()
                img_raw = bridge.imgmsg_to_cv2(msg, "bgr8")

                img = img_raw[station_y: station_y + station_height, station_x: station_x + station_width]
                bgr_img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
                hsv_img = cv2.cvtColor(bgr_img, cv2.COLOR_RGB2HSV)

                # 흰색 영역 선별
                lower_white = (0, 0, 133)
                upper_white = (179, 15, 255)
                thresh = cv2.inRange(hsv_img, lower_white, upper_white)
                kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
                thresh_open = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)
                (x, y) = (0, 0)
                roi = img[y: y + 360, x: x + 640]
                cnt, _, stats, centroids = cv2.connectedComponentsWithStats(thresh_open)
                a = np.array(stats)
                stats = a.tolist()
                stats.sort(key=lambda n: n[4], reverse=True)
                if cnt == 1:
                    (x, y, w, h_1, s) = stats[0]
                else:
                    (x, y, w, h_1, s) = stats[1]
                # print("test")

                if 100 < s < 20000:
                    cv2.rectangle(img, (x, y, w, h_1), (0, 255, 0), 2)

                # 파란색 영역 선별
                lower_blue = (100, 170, 115)
                upper_blue = (120, 230, 180)
                thresh_2 = cv2.inRange(hsv_img, lower_blue, upper_blue)
                kernel_2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
                thresh_open_2 = cv2.morphologyEx(thresh_2, cv2.MORPH_DILATE, kernel_2)
                (x_2, y_2) = (0, 0)
                roi_2 = img[y_2: y_2 + 360, x_2: x_2 + 640]
                cnt_2, _, stats_2, centroids_2 = cv2.connectedComponentsWithStats(thresh_open_2)
                a_2 = np.array(stats_2)
                stats_2 = a_2.tolist()
                stats_2.sort(key=lambda n: n[4], reverse=True)
                if cnt_2 == 1:
                    (x_2, y_2, w_2, h_2, s_2) = stats_2[0]
                else:
                    (x_2, y_2, w_2, h_2, s_2) = stats_2[1]

                if 100 < s_2 < 20000:
                    cv2.rectangle(img, (x_2, y_2, w_2, h_2), (0, 0, 255), 2)

                if h_1 > (base_y_rng - 10):
                    h_1 = 0

                if h_2 > (base_y_rng - 10):
                    h_2 = 0

                if h_1 > h_2:
                    final_h = h_1
                else:
                    final_h = h_2

                # image_ori = imutils.resize(img, width=640)
                # cv2.imshow('ORI_image', image_ori)
                # cv2.imshow('thresh_2', thresh_2)
                # cv2.imshow('open_result2', thresh_open_2)
                cv2.waitKey(25)
                if final_h > 0:
                    height_kf = float(kf(final_h)[0][0])

                    # final data
                    if height_kf == 0:
                        height_kf = 1

                    # cal_distance = 841/height_kf + 3.675
                    cal_distance = 858 / height_kf + 3.675

                    # print('result_distance: %s' % distance_for_command)
                    cal_x = -cal_distance * math.cos(imu_yaw)
                    cal_y = -cal_distance * math.sin(imu_yaw)

                    base_distance = cal_distance

            except CvBridgeError as e:
                err_code = 6
                print("image callback except Error", e)
                print(e)
                pass

    except Exception as e:
        err_code = 6
        print("image callback except Error", e)
        pass


def system_monitor(system_msg):
    try:
        global power_health, power_level, power_saver, battery_mode, \
            battery_mode_str, solar_ok, power_rate, power_health_str

        power_health = system_msg.power_health
        if battery_mode == 1:
            power_health_str = "Low Power"
        elif battery_mode == 2:
            power_health_str = "Emergency"
        else:
            power_health_str = "OK"
        power_level = system_msg.power_level
        power_saver = system_msg.power_saver
        battery_mode = system_msg.battery_mode
        if battery_mode == 1:
            battery_mode_str = "Charge High"
        elif battery_mode == 2:
            battery_mode_str = "Charge NORMAL"
        elif battery_mode == 3:
            battery_mode_str = "Charge SLOW"
        elif battery_mode == 4:
            battery_mode_str = "Discharge HIGH"
        elif battery_mode == 5:
            battery_mode_str = "Discharge NORMAL"
        elif battery_mode == 6:
            battery_mode_str = "Discharge SLOW"
        elif battery_mode == 7:
            battery_mode_str = "Discharge CONSERVE"
        elif battery_mode == 8:
            battery_mode_str = "Repair Fast Charge"
        else:
            battery_mode_str = "NO Charge"
        solar_ok = system_msg.solar_ok
        power_rate = system_msg.power_rate

        # rospy.loginfo('S1) Found!!! type : %s, D : %.1fm (x : %.1f, y : %.1f)',
        #               vol_type, vol_dis, odom_x, odom_y)

    except Exception as e:
        global err_code
        err_code = 3
        print("vol_callback except Error : ", e)
        pass


def vol_callback(volt_msg):
    try:
        global vol_type, vol_dis, pre_vol_type, vol_index, pre_vol_index, \
            center_check, center, before_score_time, v_index, vol_x, vol_y, \
            vol_stop, brake_data, vol_point, team_state, vol_dis_old, \
            turn_count, now_vol_dis
        vol_type = volt_msg.vol_type
        vol_dis = volt_msg.distance_to
        if ((1.9 > vol_dis > 0 and odom_x != 0.0 and odom_y != 0.0) or team_state == 1) and not in_pit:
            # rospy.loginfo('S1) Found %d!!! type : %s, D : %.1fm (x : %.1f, y : %.1f)',
            #               v_index, vol_type, vol_dis, odom_x, odom_y)

            v_flag = True
            if v_index > 0:
                for i in range(1, v_index + 1):
                    # rospy.loginfo('S1) Check Vol %d!!! (x : %.1f, y : %.1f)',
                    #               v_index, vol_point[i][1] - odom_x, vol_point[i][2] - odom_y)
                    if vol_point[i][1] - odom_x < 10 and vol_point[i][2] - odom_y < 10:
                        v_flag = False

            v_flag = False  # for debug

            if v_flag:
                if vol_dis < 0:
                    vol_dis = 2.0

                if team_state == 0:
                    vol_dis_old = vol_dis
                    team_state = 1
                    team_state_pub.publish(Int32(data=1))

                now_vol_dis = vol_dis

                if (vol_dis - 0.0035) > vol_dis_old:
                    turn_count = turn_count + 1
                    vol_dis_old = vol_dis

                if vol_dis < vol_dis_old:
                    vol_dis_old = vol_dis

                stop_turn = True

                if turn_count >= 3 and stop_turn:
                    vol_dis += 0.65
                    find_vol_pose_x = odom_x + (vol_dis * math.cos(imu_yaw))
                    find_vol_pose_y = odom_y + (vol_dis * math.sin(imu_yaw))

                    v_index = v_index + 1
                    vol_point[v_index][0] = 0
                    vol_point[v_index][1] = find_vol_pose_x
                    vol_point[v_index][2] = find_vol_pose_y
                    vol_point[v_index][3] = vol_dis
                    vol_point[v_index][4] = imu_yaw
                    vol_point[v_index][5] = rospy.Time.now().to_sec()
                    vol_type_array[v_index] = vol_type
                    turn_count = 0
                    team_state = 2
                    vol_dis_old = 2

                    team_state_pub.publish(Int32(data=2))

    except Exception as e:
        global err_code
        err_code = 3
        print("vol_callback except Error : ", e)
        pass


def get_joint(joint_data):
    global bl_joint
    bl_joint = joint_data.position[1]


def move_con(go, turn):
    global fl_vel, fr_vel, bl_vel, br_vel, fr_float64, fl_float64, br_float64, bl_float64, turn_ratio

    turn_ratio = 0.5
    if center_check:
        turn_ratio2 = 0.3
    else:
        turn_ratio2 = 0.2

    if turn > 0:
        if abs(turn) > 0.8:
            fr_float64 = math.pi / 4
            fl_float64 = - math.pi / 4
            br_float64 = - math.pi / 4
            bl_float64 = math.pi / 4
            fl_vel = math.pi * turn * turn_ratio2
            fr_vel = -math.pi * turn * turn_ratio2
            bl_vel = math.pi * turn * turn_ratio2
            br_vel = -math.pi * turn * turn_ratio2
        else:
            fr_float64 = 0
            fl_float64 = 0
            br_float64 = 0
            bl_float64 = 0
            turn = turn * turn_ratio
            fl_vel = turn + go
            fr_vel = -turn + go
            bl_vel = turn + go
            br_vel = -turn + go

    elif turn < 0:
        if abs(turn) > 0.8:
            fr_float64 = math.pi / 4
            fl_float64 = - math.pi / 4
            br_float64 = - math.pi / 4
            bl_float64 = math.pi / 4
            fl_vel = math.pi * turn * turn_ratio2
            fr_vel = -math.pi * turn * turn_ratio2
            bl_vel = math.pi * turn * turn_ratio2
            br_vel = -math.pi * turn * turn_ratio2
        else:
            fr_float64 = 0
            fl_float64 = 0
            br_float64 = 0
            bl_float64 = 0
            turn = turn * turn_ratio
            fl_vel = turn + go
            fr_vel = -turn + go
            bl_vel = turn + go
            br_vel = -turn + go

    else:
        fl_vel = go
        fr_vel = go
        bl_vel = go
        br_vel = go
        fr_float64 = 0
        fl_float64 = 0
        br_float64 = 0
        bl_float64 = 0

    fr_vel_pub.publish(fl_vel)
    fl_vel_pub.publish(fr_vel)
    br_vel_pub.publish(bl_vel)
    bl_vel_pub.publish(br_vel)
    FR_pub.publish(fr_float64)
    FL_pub.publish(fl_float64)
    BR_pub.publish(br_float64)
    BL_pub.publish(bl_float64)


def odom_gen(scout1_data):
    global start_x, start_y, start_z, start_roll, start_pitch, start_yaw, imu_init

    start_pose = scout1_data.pose
    init_x = start_pose.position.x
    init_y = start_pose.position.y
    init_z = start_pose.position.z

    list_orientation = [start_pose.orientation.x, start_pose.orientation.y,
                        start_pose.orientation.z, start_pose.orientation.w]
    init_roll, init_pitch, init_yaw = euler_from_quaternion(list_orientation)

    start_yaw = start_yaw - math.degrees(imu_yaw - init_yaw)
    start_pitch = start_pitch - math.degrees(imu_pitch - init_pitch)

    reset_odom_service_name = '/small_scout_1/reset_odom_to_pose'
    reset_odom_srv_class = rosservice.get_service_class_by_name(reset_odom_service_name)
    reset_odom_srv_client = rospy.ServiceProxy(reset_odom_service_name, reset_odom_srv_class)
    reset_odom_srv_client(init_x, init_y, init_z, init_roll, init_pitch, init_yaw)

    imu_init = False


def srv_enable_robot_position_callback(robot_name, data):
    rospy.wait_for_service(robot_name + '/get_true_pose')
    try:
        pose_service_name = robot_name + '/get_true_pose'
        pose_srv_class = rosservice.get_service_class_by_name(pose_service_name)
        pose_srv_client = rospy.ServiceProxy(pose_service_name, pose_srv_class)
        robot_pos = pose_srv_client(data)
        # robot_position_srv = rospy.ServiceProxy(robot_name+'/get_true_pose', LocalizationSrv)
        # robot_pos = robot_position_srv(data)
        print(robot_pos)
        odom_gen(robot_pos)
        return robot_pos
    except rospy.ServiceException as e:
        print("Get true pose Service call failed: %s" % e)

        print("S1 set init pose")
        reset_odom_service_name = '/small_scout_1/reset_odom_to_pose'
        reset_odom_srv_class = rosservice.get_service_class_by_name(
            reset_odom_service_name)
        reset_odom_srv_client = rospy.ServiceProxy(reset_odom_service_name,
                                                   reset_odom_srv_class)
        reset_odom_srv_client(12.0, 4.0, 1.648, 0.0, 0.0, 0.783999)
        pass


def imu_callback(incomming_msg):
    try:
        list_orientation = [incomming_msg.orientation.x, incomming_msg.orientation.y,
                            incomming_msg.orientation.z, incomming_msg.orientation.w]
        rolls, pitchs, yaws = euler_from_quaternion(list_orientation)
        global imu_yaw, imu_pitch, points, angle_point, start_yaw, imu_init, start_pitch
        yaw_or = math.radians(math.degrees(yaws) + start_yaw)

        point = np.array([math.cos(yaw_or), math.sin(yaw_or)])

        N_size = angle_filter_size
        global x_point, y_point
        x_point = 0
        y_point = 0
        pitch_sum = 0
        for i in range(N_size, 1, -1):
            points[i - 1] = points[i - 2]
            pitch_points[i - 1] = pitch_points[i - 2]
            x_point = x_point + points[i - 1][0]
            y_point = y_point + points[i - 1][1]
            pitch_sum = pitch_sum + pitch_points[i - 1]
        points[0] = point
        pitch_points[0] = pitchs
        x_point = x_point + points[0][0]
        y_point = y_point + points[0][1]
        pitch_sum = pitch_sum + pitch_points[0]
        # print(points[0])
        # rospy.loginfo(Robot_tag+"point is [%f , %f]", point[0], point[1])

        x_point = x_point / N_size
        y_point = y_point / N_size
        if imu_init:
            init_yaw = math.atan2(y_point, x_point)
            init_pitch = pitch_sum / N_size
            if points[N_size - 1][0] != 0:
                start_yaw = start_yaw - (math.degrees(init_yaw) - yaw_d)
                start_yaw = math.degrees(0.783999)
                start_pitch = start_pitch - (math.degrees(init_pitch) - math.degrees(pitch))
                imu_init = False

        else:
            imu_pitch = pitch_sum / N_size
            imu_yaw = math.atan2(y_point, x_point)

        imu_yaw = float(kf_yaw(imu_yaw)[0][0])
    except ValueError as e:
        global err_code
        err_code = 1
        print("imu_callback except Error", e)
        pass


def odom_callback(odom_data):
    try:
        global start_flag, odom_x, odom_y, odom_z, odom_roll, odom_pitch, odom_yaw, roll, pitch, yaw, yaw_d, \
            start_x, start_y, start_z, start_roll, start_pitch, start_yaw, speed
        now_pose = odom_data.pose.pose
        odom_x = now_pose.position.x
        odom_y = now_pose.position.y
        odom_z = now_pose.position.z

        list_orientation = [now_pose.orientation.x, now_pose.orientation.y,
                            now_pose.orientation.z, now_pose.orientation.w]
        odom_roll, odom_pitch, odom_yaw = euler_from_quaternion(list_orientation)

        if odom_yaw != 0:
            roll = odom_roll
            pitch = odom_pitch
            yaw = odom_yaw
            yaw_d = math.degrees(odom_yaw)
            # if math.degrees(pitch) < -10:
            #     speed = speed + 0.1
            # else:
            #     speed = 2.0

        if start_flag == 0:
            start_flag = 1
            start_x = odom_x
            start_y = odom_y
            start_z = odom_z
            # start_yaw = yaw_d
            # start_pitch = odom_pitch

        #     scout_1_pos = srv_enable_robot_position_callback('/scout_1',True)
        #     odom_gen(scout_1_pos)
    except Exception as e:
        global err_code
        err_code = 2
        print("odom_callback except Error")
        pass


def kf(x_new):
    try:
        global xp, P, R
        Pp = np.dot(np.dot(A, P), A.T) + Q
        K = np.dot(np.dot(Pp, H.T), lin.inv(np.dot(np.dot(H, Pp), H.T) + R))
        x = xp + K * (x_new - np.dot(H, xp))
        P = Pp - np.dot(np.dot(K, H), Pp)
        xp = x
        return x
    except Exception as e:
        global err_code
        err_code = 5
        return x_new


def kf_yaw(x_new):
    try:
        global xp_yaw, P_yaw, R_yaw
        Pp = np.dot(np.dot(A, P_yaw), A.T) + Q
        K = np.dot(np.dot(Pp, H.T), lin.inv(np.dot(np.dot(H, Pp), H.T) + R))
        x = xp_yaw + K * (x_new - np.dot(H, xp_yaw))
        P_yaw = Pp - np.dot(np.dot(K, H), Pp)
        xp_yaw = x
        return x
    except Exception as e:
        global err_code
        err_code = 5
        return x_new


def kf2(x_new):
    try:
        global xp2, P, R
        Pp = np.dot(np.dot(A, P), A.T) + Q
        K = np.dot(np.dot(Pp, H.T), lin.inv(np.dot(np.dot(H, Pp), H.T) + R))
        x = xp2 + K * (x_new - np.dot(H, xp2))
        P = Pp - np.dot(np.dot(K, H), Pp)
        xp2 = x
        return x
    except Exception as e:
        global err_code
        err_code = 5
        return x_new


class Obstacle:
    def __init__(self):
        # self._cmd_pub = rospy.Publisher('scout_1/skid_cmd_vel', Twist, queue_size=1)
        self.obstacle()

    def getKey(self):
        if os.name == 'nt':
            return msvcrt.getch()
        tty.setraw(sys.stdin.fileno())
        rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
        if rlist:
            key = sys.stdin.read(1)
        else:
            key = ''
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
        return key

    def cmd_check(self, target_linear_vel, target_angular_vel, turtlebot_moving, GTG):
        try:
            key = self.getKey()
            global goal_x, goal_y, slam, goal, center_check, center, turn_to_goal, find_object_time, \
                fr_float64, fl_float64, br_float64, bl_float64, find_object, object_x_center, turn_circle, speed, \
                fl_vel, fr_vel, bl_vel, br_vel, sensor_pitch_value

            cmd_turn_ratio = 0.7

            if key == 'w':
                turtlebot_moving = True
                center_check = True
                GTG = False
                fl_vel = speed
                fr_vel = speed
                bl_vel = speed
                br_vel = speed
                fr_float64 = 0
                fl_float64 = 0
                br_float64 = 0
                bl_float64 = 0
                print("go : ", speed)
            elif key == 'x':
                turtlebot_moving = False

                center_check = True
                GTG = False
                fl_vel = -speed
                fr_vel = -speed
                bl_vel = -speed
                br_vel = -speed
                fr_float64 = 0
                fl_float64 = 0
                br_float64 = 0
                bl_float64 = 0
                print("back : ", speed)
            elif key == 'a':
                turtlebot_moving = False

                center_check = True
                GTG = False
                fl_vel = tnspeed * cmd_turn_ratio
                fr_vel = -tnspeed * cmd_turn_ratio
                bl_vel = tnspeed * cmd_turn_ratio
                br_vel = -tnspeed * cmd_turn_ratio
                fr_float64 = math.pi / 4
                fl_float64 = - math.pi / 4
                br_float64 = - math.pi / 4
                bl_float64 = math.pi / 4
                print("left : ", tnspeed)
            elif key == 'd':
                turtlebot_moving = False

                center_check = True
                GTG = False
                fl_vel = -tnspeed * cmd_turn_ratio
                fr_vel = tnspeed * cmd_turn_ratio
                bl_vel = -tnspeed * cmd_turn_ratio
                br_vel = tnspeed * cmd_turn_ratio
                fr_float64 = math.pi / 4
                fl_float64 = - math.pi / 4
                br_float64 = - math.pi / 4
                bl_float64 = math.pi / 4
                print("right : ", tnspeed)
            elif key == 'z':
                center_check = False
                center = 600
                rospy.loginfo('Find base!!!')
            elif key == 'g':
                center_check = True
                GTG = True
                rospy.loginfo('S1) Go to goal!!')
            elif key == 'j':
                goal_x = goal_x - 10
                rospy.loginfo('S1) goal is %d, %d', goal_x, goal_y)
            elif key == 'l':
                goal_x = goal_x + 10
                rospy.loginfo('S1) goal is %d, %d', goal_x, goal_y)
            elif key == 'i':
                goal_y = goal_y + 10
                rospy.loginfo('S1) goal is %d, %d', goal_x, goal_y)
            elif key == 'k':
                goal_y = goal_y - 10
                rospy.loginfo('S1) goal is %d, %d', goal_x, goal_y)
            elif key == 'o':
                sensor_pitch_value = sensor_pitch_value - 1
                angle = math.radians(sensor_pitch_value)
                sensor_pitch.publish(angle)
                print("angle up : ", angle)
            elif key == 'p':
                sensor_pitch_value = sensor_pitch_value + 1
                angle = math.radians(sensor_pitch_value)
                sensor_pitch.publish(angle)
                print("angle down : ", angle)

            elif key == 'v':
                print(vol_point)

            elif key == 'b':
                goal += 1
                goal_x = goal_point[goal][0]
                goal_y = goal_point[goal][1]
                center_check = True
                GTG = True
                rospy.loginfo('S1) Go to goal!!')

            elif key == ' ' or key == 's':
                turtlebot_moving = False

                center_check = True
                GTG = False
                fl_vel = 0
                fr_vel = 0
                bl_vel = 0
                br_vel = 0
                fr_float64 = 0
                fl_float64 = 0
                br_float64 = 0
                bl_float64 = 0
                print("stop : ", speed)
            elif key == 'q':
                rospy.loginfo('S1) Quit!!')
                quit()
                # os.system("")
                rospy.signal_shutdown("Quit signal")

            return target_linear_vel, target_angular_vel, turtlebot_moving, GTG
        except Exception as e:
            global err_code
            if err_code == 0:
                err_code = 8
            rospy.loginfo('S1) Quit signal!!')
            rospy.loginfo('S1) Quit signal!!')
            rospy.loginfo('S1) Quit signal!!')
            rospy.loginfo('S1) Quit signal!!')
            rospy.loginfo('S1) get key error!!')
            rospy.loginfo('S1) get key error!!')
            rospy.loginfo('S1) get key error!!')
            rospy.loginfo('S1) get key error!!')
            rospy.loginfo('S1) get key error!!')
            rospy.loginfo('S1) get key error!!')
            return target_linear_vel, target_angular_vel, turtlebot_moving, GTG
            pass

    def cal(self, x, y, z, angle, dis, gradient, dt, twists):
        global err_code
        try:
            # x_pose,y_pose,z_pose=self.cal(x_pose,y_pose,z_pose,angle,interval*1.5,0)
            if dt == 0:
                dt = 0.1
                err_code = 9
                print("cal dt zero Error")
            theta = math.radians(angle)
            alpha = gradient
            ran = dis / sigma
            r_dot = ran * math.cos(alpha)
            x_dot = r_dot * math.cos(theta)
            y_dot = r_dot * math.sin(theta)
            z_dot = ran * math.sin(alpha)
            x = x + x_dot
            y = y + y_dot
            z = z - z_dot

            velEst = np.array([x_dot / dt, y_dot / dt])

            return x, y, z, velEst
        except Exception as e:
            err_code = 9
            print("cal except Error")
            return x, y, z, 0.0

    def obstacle(self):
        global turn_to_goal, vol_rng, goal_x, goal_y, center_check, slam_check, goal, dt, start_flag, \
            base_x, base_y, goal_point, center, speed, far_from_base, err_code, vol_dis, vol_stop, brake_data, \
            fr_float64, fl_float64, br_float64, bl_float64, vol_point, float64, find_object_time, \
            find_object, call_step, object_x_center, marker_x_center, turn_circle, \
            slam, in_pit, need_base

        twist = Twist()

        turning = False
        pre_turn = False
        turtlebot_moving = False
        GTG = False
        boundary = False

        step_goal = False
        reset_odom = False

        angle_range = range(0, 100)  # 0~100 is 0~180 degree,
        target_linear_vel = 0.0
        target_angular_vel = 0.0
        clock = rospy.get_time()
        current_time = rospy.Time.now()
        last_time = rospy.Time.now()
        x_pose = start_x
        y_pose = start_y
        z_pose = start_z
        interval = 0.0
        angle = 0.0
        target_x = 0
        target_y = 0
        target_angle = 0
        obs_flag = 0
        turn_flag = 0
        center_check_flag = 0
        object_check_flag = 0
        pre_x_pose = 0.0
        pre_y_pose = 0.0
        pre_yaw = 0.0
        light_data_f = 1.0
        center_chk_time = rospy.Time.now()
        move_wait_time = rospy.Time.now()
        wait_x_pose = 0.0
        wait_y_pose = 0.0
        pre_center = 0.0
        base_flag = 0
        first_found_object_flag = 0
        pre_fl_float64 = 0
        before_call_time = rospy.Time.now()
        find_time = 80.0
        forward_time = 30.0
        go_time = find_time + forward_time
        get_pose_result = 0
        backward_flag = 0
        time_offset = 0.0
        recall_time = 0.0
        in_pit_flag = 0
        need_base_flag = 0

        finding_object_goal_x = 0
        finding_object_goal_y = 0
        find_both_go = False
        # rospy.loginfo('S1) Change sensor to %f', float64.data)
        # if float64.data != 0:
        #     for i in range(500):
        #         pub2.publish(float64)
        #         rospy.loginfo('S1) Change sensor to %f', float64.data)

        float64.data = 0.35

        auto_start = True

        if auto_start:
            center_check = True
            # center = 600
            slam = True
            goal = 1
            goal_x = goal_point[goal][0]
            goal_y = goal_point[goal][1]
            turtlebot_moving = False
            GTG = True
            rospy.loginfo('Slam!!!')

        while not rospy.is_shutdown():
            # rospy.loginfo('S1) rospy.is_shutdown()? %s', rospy.is_shutdown())
            try:
                # rospy.loginfo('S1) Try start')

                # pub2.publish(float64)
                pre_mindistance = 200
                pre_index = 0
                min_distance = 200
                index = 0
                target_linear_vel, target_angular_vel, turtlebot_moving, GTG = \
                    self.cmd_check(target_linear_vel, target_angular_vel, turtlebot_moving, GTG)
                try:
                    scan = rospy.wait_for_message('small_scout_1/laser/scan', LaserScan, timeout=1)
                except rospy.ROSException as e:
                    # rospy.loginfo('S1) Timeout while waiting for scan info')
                    # rospy.logerr("Timeout while waiting for scan info!")
                    err_code = 15
                    raise e
                scan_result = LaserScan()
                scan_result.header = scan.header
                scan_result.angle_increment = scan.angle_increment
                scan_result.angle_min = scan.angle_min
                scan_result.angle_max = scan.angle_max
                scan_result.intensities = scan.intensities
                scan_result.scan_time = scan.scan_time
                scan_result.range_max = 100.0
                con_ref = 15
                con = con_ref
                obs_start = 0
                obs_index = 0
                obs_end = 0
                angle_add = 0
                turn_dir = 0
                pre_turn_dir = 0
                obs_i = []
                obs_r = [float('inf') for _ in angle_range]
                max_con = 0
                pre_lidar_distances = 0
                pre2_lidar_distances = 0


                max_distance = 9.5

                max_i = 0
                avoid_ref = 45
                too_close = 0
                tc_start = 0
                tc_end = 0
                turning = False
                con_end = False
                # rospy.loginfo('S1) Try scan check')
                for i in angle_range:
                    lidar_distances = scan.ranges[i]

                    if not turning:
                        #  CONTINUITY
                        if i >= 99:
                            con += con_ref
                        if not con_end and lidar_distances != 0:
                            if lidar_distances < 1:
                                if tc_start == 0:
                                    tc_start = i
                                too_close = too_close + 1
                                tc_end = i
                            if con == 0:
                                obs_start = i
                            if abs((pre2_lidar_distances + pre_lidar_distances) / 2
                                   - (pre_lidar_distances + lidar_distances) / 2) < 0.5:
                                con = con + 1
                            else:
                                con_end = True
                        else:
                            if con > max_con:
                                max_con = con
                            # if 3 < con < 95:
                            #     rospy.loginfo('S1) Continous %d : MAX is %d , i: %d !!', con, max_con, i)
                            if 3 < con < con_ref:
                                for con_index in range(obs_start, i):
                                    # obs_i.append(con_index)
                                    obs_r[con_index] = scan.ranges[con_index]
                                min_distance = pre_mindistance
                                if min_distance < STOP_DISTANCE:
                                    index = pre_index
                                    # rospy.loginfo('S1) Find obs %f !!', obs_index)

                                    rospy.loginfo('S1) Find obs con %d to %d !! r=%f, i=%f',
                                                  obs_start, i, min_distance, index)
                                    obs_index = obs_index + 1
                                    pre_mindistance = 200
                                    max_i = i
                                    if not 1 < team_state or need_base:
                                        turning = True

                                    if abs(math.degrees(odom_pitch)) > 10:  # too H/L angle don't turn
                                        rospy.loginfo('S1) Too H/L angle : %f', math.degrees(odom_pitch))
                                        # turning = False
                            con = 0
                            con_end = False
                        if pre_mindistance > lidar_distances:
                            pre_mindistance = lidar_distances
                            pre_index = i
                            # rospy.loginfo('S1) LOW! %f, %f', min_distance,i)
                    pre2_lidar_distances = pre_lidar_distances
                    pre_lidar_distances = lidar_distances

                if 250 < vol_center < 390 and team_state < 1 and not need_base and not turn_to_goal:

                    # y_min = vol_y_center-(.5*vol_height)
                    if abs(vol_y) > 230:
                        turning = True
                        step_goal = True
                        step_ref = 5
                        if vol_center < 320:
                            turn_yaw = math.radians(yaw_d - 30)
                        else:
                            turn_yaw = math.radians(yaw_d + 30)
                        goal_x = x_pose + step_ref * math.cos(turn_yaw)
                        goal_y = y_pose + step_ref * math.sin(turn_yaw)
                        index = (640 - vol_center) * (100 / 640)

                    rospy.loginfo('S1) Found vol (yolo)!! Xcenter:%d, Ymin:%d, width:%d, height:%d, angle:%d',
                                  vol_center, vol_y, vol_width, vol_height, index)

                if turtlebot_moving or GTG:
                    target_linear_vel = speed
                    target_angular_vel = 0

                if turning:
                    turn_flag = turn_flag + 1
                    rospy.loginfo('S1) Turn_flag up!! : %d', turn_flag)

                    if turn_flag < 2:
                        turning = False
                    if turn_flag > 4:
                        turn_flag = 4

                else:
                    rospy.loginfo('S1) Turn_flag do!! : %d', turn_flag)
                    turn_flag = turn_flag - 1
                    if turn_flag < 0:
                        turn_flag = 0

                rospy.loginfo('S1) Check!! Turning : %d, GTG : %d, TM : %d, CC : %d, TTG : %d, SLAM : %d',
                              turning, GTG, turtlebot_moving, center_check, turn_to_goal, slam_check)

                # if (turning and GTG and not turn_to_goal and not turn_circle) or \
                #         (turning and turtlebot_moving and not turn_to_goal and not turn_circle):

                # if slam and goal == 1:
                #     turning = False

                if turning and center_check and (GTG or turtlebot_moving) and not turn_to_goal:
                    turn_ref = 40
                    angle_add = 10
                    turn_spd = tnspeed * (50 - abs(index - 50)) / 20
                    rospy.loginfo('S1) Try Avoid index : %d', turning and center_check and (GTG or turtlebot_moving))
                    # rospy.loginfo('S1) Try Avoid index : %d', index)
                    if index < 50:
                        turn_spd = tnspeed * abs(index - 50) / 10
                        if turn_spd < 1:
                            turn_spd = 1

                        if turn_flag > 9 and goal > 1:
                            step_goal = True
                            obs_yaw = yaw_d + (index - 50) * 74 / 50
                            turn_yaw = math.radians(obs_yaw + 50)
                            goal_x = x_pose + 10 * math.cos(turn_yaw)
                            goal_y = y_pose + 10 * math.sin(turn_yaw)
                            turn_flag = 0
                        index = max_i
                        rospy.loginfo('S1) Left Avoid angle is %d to %d ', 50 - turn_ref - angle_add, 50 - turn_ref)

                        target_linear_vel = -0.1
                        if too_close > 5:
                            target_linear_vel = -1
                        turn_speed = turn_spd
                        rospy.loginfo('S1) Turn left avoid!! %f speed : %f', index, turn_speed)
                    else:
                        if turn_spd < 1:
                            turn_spd = 1
                        if turn_flag > 9 and goal > 1:
                            step_goal = True
                            obs_yaw = yaw_d + (index - 50) * 74 / 50
                            turn_yaw = math.radians(obs_yaw - 50)
                            goal_x = x_pose + 10 * math.cos(turn_yaw)
                            goal_y = y_pose + 10 * math.sin(turn_yaw)
                            turn_flag = 0
                        index = obs_start
                        rospy.loginfo('S1) Right Avoid angle is %d to %d ', 50 + turn_ref, 50 + turn_ref + angle_add)

                        target_linear_vel = -0.1
                        if too_close > 5:
                            target_linear_vel = -1
                        turn_speed = -turn_spd
                        rospy.loginfo('S1) Turn right avoid !! %f speed : %f', index, turn_speed)
                        boundary = True
                        turn_dir = 2

                    rospy.loginfo('S1) avoid!')
                    twist.linear.x = target_linear_vel
                    twist.angular.z = turn_speed
                    # interval = rospy.get_time() - clock
                    # clock = rospy.get_time()
                    current_time = rospy.Time.from_sec(rospy.Time.now().to_sec() + time_offset)
                    dt = (current_time - last_time).to_sec()
                    if dt == 0:
                        err_code = 13
                        dt = 0.1
                        rospy.loginfo('S1) dt Zero Error!!! %d ', err_code)

                    # if abs(twist.angular.z) > 0.8:
                    #     fr_float64.data = 0.78
                    #     fl_float64.data = -0.78
                    #     br_float64.data = -0.78
                    #     bl_float64.data = 0.78
                    # else:
                    #     fr_float64.data = 0.0
                    #     fl_float64.data = 0.0
                    #     br_float64.data = 0.0
                    #     bl_float64.data = 0.0

                    # angle = angle + turn_speed * interval
                    angle = yaw_d
                    x_pose, y_pose, z_pose, velEst = self.cal(x_pose, y_pose, z_pose, angle,
                                                              dt * target_linear_vel, pitch, dt, twist)
                    rospy.loginfo('S1) Distance : %f , angle : %f ', min_distance, index * 1.48)
                else:
                    # rospy.loginfo('S1) Try Go')
                    angle = yaw_d

                    if GTG:
                        target_x = goal_x - x_pose
                        target_y = goal_y - y_pose
                        target_angle = math.degrees(math.atan2(target_y, target_x))
                        turn_angle = target_angle - angle

                        if turn_angle > 180:
                            turn_angle = turn_angle - 360
                        elif turn_angle < -180:
                            turn_angle = turn_angle + 360

                        turn_spd = tnspeed * abs(turn_angle) / 10
                        if turn_spd > tnspeed:
                            turn_spd = tnspeed
                        elif turn_spd < 0.3:
                            turn_spd = 0.3

                        if 0 < turn_angle:
                            target_angular_vel = turn_spd
                            rospy.loginfo('S1) Turn left!! angle : %d , speed : %f', turn_angle, turn_spd)
                            if turn_angle < 10:
                                target_linear_vel = speed
                                turn_to_goal = False
                            else:
                                target_linear_vel = 0
                                turn_to_goal = True

                        if turn_angle < 0:
                            rospy.loginfo('S1) Turn right!! angle : %d , speed : %f', turn_angle, -turn_spd)
                            target_angular_vel = -turn_spd
                            if turn_angle > -10:
                                target_linear_vel = speed
                                turn_to_goal = False
                            else:
                                target_linear_vel = 0
                                turn_to_goal = True

                        reach_ref = 5
                        if step_goal:
                            reach_ref = 1

                        if math.sqrt(math.pow(target_x, 2) + math.pow(target_y, 2)) < reach_ref:
                            stuck_flag = 0
                            target_linear_vel = 0
                            target_angular_vel = 0
                            rospy.loginfo('S1) Reach Goal  %d, %d ', goal_x, goal_y)
                            if step_goal:
                                step_goal = False
                                goal_x = goal_point[goal][0]
                                goal_y = goal_point[goal][1]

                            else:

                                if need_base:
                                    print("Find Station!!!!")
                                    center_check_flag = 0
                                    center_check = False
                                    center = 600

                                elif team_state == 0 or goal < 3:
                                    goal += 1
                                goal_x = goal_point[goal][0]
                                goal_y = goal_point[goal][1]
                                print("Go to next point")

                                if team_state == 0 and goal % 2 == 0 and goal > 3: # 일정 웨이포인트마다 베이스에 보정하러 출발
                                    need_base_flag = 0
                                    in_pit = False
                                    # need_base = True
                                    # goal_x = 10
                                    # goal_y = -15
                                    # base_pub.publish(Int32(data=1))

                    twist.linear.x = target_linear_vel
                    twist.angular.z = target_angular_vel
                    # interval = rospy.get_time() - clock
                    # clock = rospy.get_time()
                    current_time = rospy.Time.from_sec(rospy.Time.now().to_sec() + time_offset)
                    dt = (current_time - last_time).to_sec()
                    if dt == 0:
                        err_code = 14
                        dt = 0.1
                        rospy.loginfo('S1) dt Zero Error2!!! %d ', err_code)

                    if not center_check and center < 640:
                        ttg = True
                        # float64.data = 0.2
                        turn_angle = 10
                        rospy.loginfo('Find center : %f, time : %f', center, (current_time - center_chk_time).to_sec())
                        move_wait_time = current_time
                        if pre_center != center:
                            center_chk_time = current_time
                        pre_center = center
                        twist.linear.x = 0.0

                        if center_check_flag > 0:
                            rospy.loginfo('========== Center_check_flag : %d,  time : %f ==========',
                                          center_check_flag, (current_time - center_found_time).to_sec())

                        if center < 317:
                            twist.angular.z = tnspeed * (320 - center) / 60
                            if twist.angular.z > tnspeed:
                                twist.angular.z = tnspeed
                            elif twist.angular.z < 0.2:
                                twist.angular.z = 0.2
                            rospy.loginfo('Find center : left %f', twist.angular.z)
                        elif center > 323:
                            twist.angular.z = tnspeed * -(center - 320) / 60
                            if twist.angular.z < -tnspeed:
                                twist.angular.z = -tnspeed
                            elif twist.angular.z > -0.2:
                                twist.angular.z = -0.2
                            rospy.loginfo('Find center : right %f', twist.angular.z)
                        else:
                            rospy.loginfo('Found center %d : %f ', center_check_flag, center)

                            if center_check_flag == 0:
                                center_found_time = current_time

                            center_check_flag = center_check_flag + 1
                            twist.linear.x = 0.0

                            if center_check_flag > 5 and (current_time - center_found_time).to_sec() > 3.5:
                                if need_base:
                                    need_base = False
                                    x_pose = base_x + cal_x
                                    y_pose = base_y + cal_y

                                    rospy.loginfo('S1) Reset Odom from base !! '
                                                  'x : %.1f, y : %.1f, z : %.1f, yaw : %f, pitch : %f ',
                                                  x_pose, y_pose, z_pose, imu_yaw, imu_pitch)
                                    reset_odom_service_name = '/small_scout_1/reset_odom_to_pose'
                                    reset_odom_srv_class = rosservice.get_service_class_by_name(
                                        reset_odom_service_name)
                                    reset_odom_srv_client = rospy.ServiceProxy(reset_odom_service_name,
                                                                               reset_odom_srv_class)
                                    reset_odom_srv_client(x_pose, y_pose, z_pose, roll, imu_pitch, imu_yaw)

                                center_check = True
                                ttg = False
                                center_check_flag = 0
                                center = 640
                                twist.angular.z = 0
                                stuck_flag = 0

                        if (current_time - center_chk_time).to_sec() > 60:
                            center = 640
                            ttg = False
                            center_check = True

                if need_base:
                    goal_x = 10
                    goal_y = -15
                    rospy.loginfo('S1) ============= Need Base Odom =============')

                elif team_state == 1:
                    rospy.loginfo('S1) New Found!!! type:%s, D:%.3f vs %.3f (x:%.2f, y:%.2f), cnt:%d',
                                  v_index, now_vol_dis, vol_dis_old, odom_x, odom_y, turn_count)

                    if turn_count % 2 == 0:
                        twist.linear.x = 0
                        twist.angular.z = 0.9
                    else:
                        twist.linear.x = 0
                        twist.angular.z = -0.9

                elif team_state > 2:  # 태양광 충전
                    twist.linear.x = 0

                    if 0 < yaw_d:
                        turn_angle = 90 - yaw_d
                    else:
                        turn_angle = -90 - yaw_d
                    if turn_angle > 180:
                        turn_angle = turn_angle - 360
                    elif turn_angle < -180:
                        turn_angle = turn_angle + 360
                    turn_spd = tnspeed * abs(turn_angle) / 20
                    if turn_spd > tnspeed:
                        turn_spd = tnspeed
                    elif turn_spd < 0.3:
                        turn_spd = 0.3

                    if 0 < turn_angle:
                        twist.angular.z = turn_spd
                        rospy.loginfo('S1) Sup Turn left!! angle : %d , speed : %f', turn_angle, turn_spd)
                    else:
                        twist.angular.z = -turn_spd
                        rospy.loginfo('S1) Sup Turn right!! angle : %d , speed : %f', turn_angle, -turn_spd)
                # elif team_state == 2 and vo:
                #     twist.linear.x = 0
                #     twist.angular.z = 0

                if GTG or (not center_check) or team_state == 1 or turtlebot_moving:
                    move_con(twist.linear.x, twist.angular.z)
                    rospy.loginfo('S1) GTG go : %.1f, turn %.1f ', twist.linear.x, twist.angular.z)

                else:
                    fr_vel_pub.publish(fl_vel)
                    fl_vel_pub.publish(fr_vel)
                    br_vel_pub.publish(bl_vel)
                    bl_vel_pub.publish(br_vel)
                    FR_pub.publish(fr_float64)
                    FL_pub.publish(fl_float64)
                    BR_pub.publish(br_float64)
                    BL_pub.publish(bl_float64)

                # rospy.loginfo('S1) -------------Check flag-------------')
                if odom_x != 0.0 and odom_y != 0.0 and odom_yaw != 0.0:
                    x_pose = odom_x
                    y_pose = odom_y
                    z_pose = odom_z

                # if (yaw == pre_yaw) and pre_x_pose != 0 and imu_yaw != 0:
                # if (odom_x == 0.0) and (odom_y == 0.0) and pre_x_pose != 0.0:
                #     reset_odom_service_name = '/small_scout_1/reset_odom_to_pose'
                #     reset_odom_srv_class = rosservice.get_service_class_by_name(reset_odom_service_name)
                #     reset_odom_srv_client = rospy.ServiceProxy(reset_odom_service_name, reset_odom_srv_class)
                #     reset_odom_srv_client(pre_x_pose, pre_y_pose, z_pose, roll, imu_pitch, imu_yaw)
                #     rospy.loginfo('S1) Reset1 Odom!! x : %f, y : %f, z : %f, yaw : %f, pitch : %f ',
                #                   pre_x_pose, pre_y_pose, z_pose, imu_yaw, imu_pitch)

                if abs(imu_yaw - yaw) > 0.1:
                    rospy.loginfo('S1) Reset!! start : %.3f(%.1f), imu : %.3f(%.1f), odom : %.3f(%.1f), diff : %.3f',
                                  math.radians(start_yaw), start_yaw, imu_yaw, math.degrees(imu_yaw),
                                  yaw, yaw_d, abs(imu_yaw - yaw))

                    reset_odom_service_name = '/small_scout_1/reset_odom_to_pose'
                    reset_odom_srv_class = rosservice.get_service_class_by_name(reset_odom_service_name)
                    reset_odom_srv_client = rospy.ServiceProxy(reset_odom_service_name, reset_odom_srv_class)
                    if abs(x_pose) < 0.1 and abs(y_pose) < 0.1 and abs(z_pose) < 0.1:
                        rospy.loginfo('S1) Reset with start odom %.1f', start_x)
                        # reset_odom_srv_client(start_x, start_y, start_z, init_roll, init_pitch, init_yaw)
                    else:
                        reset_odom_srv_client(x_pose, y_pose, z_pose, roll, imu_pitch, imu_yaw)
                    rospy.loginfo('S1) Reset2 Odom!! x : %f, y : %f, z : %f, yaw : %f, pitch : %f ',
                                  x_pose, y_pose, z_pose, imu_yaw, imu_pitch)

                if math.degrees(imu_pitch) > 13:
                    in_pit_flag += 1
                    if in_pit_flag > 3:
                        in_pit = True

                if in_pit:
                    rospy.loginfo('S1) ============= Now In pit %d =============', in_pit_flag)
                    if math.degrees(imu_pitch) < -13:
                        in_pit_flag = 0
                        in_pit = False
                        need_base_flag += 1

                if need_base_flag > 0:
                    if abs(math.degrees(imu_pitch)) < 0.5:
                        need_base_flag += 1

                    if need_base_flag > 5:
                        need_base_flag = 0
                        # need_base = True
                        # goal_x = 10
                        # goal_y = -15
                        # base_pub.publish(Int32(data=1))

                rospy.loginfo('From base X : %.2f , Y : %.2f center : %d & d : %.2f, w : %.1f (%d vs %d)',
                              base_x + cal_x, base_y + cal_y, center, base_distance, height_kf, h_1, h_2)
                rospy.loginfo('S1) Goal%d is %d, %d, target yaw is %.2f, step:%s',
                              goal, goal_x, goal_y, target_angle, step_goal)
                rospy.loginfo('S1) X:%.2f, Y:%.1f, Z:%.2f, yaw:%d (%d, %.2f), pit:%.1f, sen:%.1f, bat:%d, state:%d',
                              x_pose, y_pose, z_pose, yaw_d, math.degrees(imu_yaw),
                              imu_yaw, math.degrees(imu_pitch), sensor_pitch_value, power_level, team_state)
                # rospy.loginfo('S1) start : %.3f(%.1f), imu : %.3f(%.1f), odom : %.3f(%.1f), diff : %.3f',
                #               math.radians(start_yaw), start_yaw, imu_yaw, math.degrees(imu_yaw),
                #               yaw, yaw_d, abs(imu_yaw-yaw))
                # rospy.loginfo('S1) State : %s, level : %.1f%%, mode : %s, solar : %d, saver : %d, late : %.2f',
                #               power_health_str, power_level, battery_mode_str, solar_ok, power_saver, power_rate)

                if v_index > 0:
                    # rospy.loginfo('Found vol : %d', v_index)
                    rospy.loginfo('Found vol : %d, last : %s (%.1f, %.1f), D:%.2f, Yaw:%.1f time : %d ',
                                  v_index, vol_type_array[v_index],
                                  vol_point[v_index][1], vol_point[v_index][2], vol_point[v_index][3],
                                  vol_point[v_index][4], vol_point[v_index][5])
                    vol_data = ScoreMsg()
                    vol_data.header = scan.header
                    vol_data.header.frame_id = "small_scout_1_state_data"
                    vol_data.score = v_index
                    vol_data.types_collected = [vol_type_array[v_index]]
                    vol_data.masses_collected_kg = [vol_point[v_index][1], vol_point[v_index][2], vol_point[v_index][3]]
                    vol_pub.publish(vol_data)

                if slam:
                    rospy.loginfo('S1) Go to next point !!! %d ', goal)

                if get_pose_result > 0:
                    rospy.loginfo('S1) ========== Get_pose_result %d !!! ==========', get_pose_result)

                last_time = current_time
                scan_result.ranges = obs_r
                # scan_pub.publish(scan_result)

                state_data = ScoreMsg()
                state_data.header = scan.header
                state_data.header.frame_id = "small_scout_1_state_data"
                state_data.score = 1
                state_data.masses_collected_kg = [x_pose, y_pose, z_pose, sensor_pitch_value,
                                                  imu_yaw, yaw, goal_x, goal_y, power_level]
                state_pub.publish(state_data)

                pre_x_pose = x_pose
                pre_y_pose = y_pose
                pre_yaw = yaw
                # rospy.loginfo('S1) rospy.is_shutdown()? 2 %s', rospy.is_shutdown())

            except Exception as e:
                err_code = 10
                print("Obstacle except Error", e)
                pass
        rospy.loginfo('S1) Ros is shutdown!!!! %s', rospy.is_shutdown())


def shut_down():
    print("Ros is shutdown!! code : %d " % err_code)


def main():
    if os.name != 'nt':
        settings = termios.tcgetattr(sys.stdin)
    rospy.init_node('turtlebot3_teleop')
    rospy.on_shutdown(shut_down)
    rospy.Subscriber('small_scout_1/volatile_sensor', VolSensorMsg, vol_callback)
    global light_data

    sleep_second = 10

    global angle_point, before_score_time, vol_type_array
    before_score_time = rospy.Time.now()

    for i in range(0, 360):
        line = [math.cos(math.radians(i)), math.sin(math.radians(i))]
        angle_point[i] = line

    rospy.loginfo(vol_type_array)

    # Set up your subscriber and define its callback
    rospy.Subscriber(image_topic, Image, image_callback)
    # rospy.Subscriber('/darknet_ros/bounding_boxes', BoundingBoxes, box)
    rospy.Subscriber('/darknet_ros/bounding_boxes_t1', BoundingBoxes, box)

    rospy.Subscriber('team_1/state', Int32, state_callback)

    rospy.Subscriber('small_scout_1/odom', Odometry, odom_callback)
    rospy.Subscriber('small_scout_1/imu', Imu, imu_callback)
    rospy.Subscriber("small_scout_1/joint_states", JointState, get_joint)
    # light_srv_client("%s" % light_data)
    rospy.Subscriber('small_scout_1/system_monitor', SystemMonitorMsg, system_monitor)

    rospy.loginfo('S1) Ros is start!!!! %s', rospy.is_shutdown())

    brake_service_name = '/small_scout_1/brake_rover'
    brake_srv_class = rosservice.get_service_class_by_name(brake_service_name)
    brake_srv_client = rospy.ServiceProxy(brake_service_name, brake_srv_class)
    brake_result = brake_srv_client(brake_data)

    light_data = 0.0
    spot_light_service_name = '/small_scout_1/spot_light'
    spot_light_srv_class = rosservice.get_service_class_by_name(spot_light_service_name)
    spot_light_srv_client = rospy.ServiceProxy(spot_light_service_name, spot_light_srv_class)
    spot_light_srv_client(light_data)

    saver_data = True  # stop / low / high
    saver_service_name = '/small_scout_1/system_monitor/power_saver'
    saver_srv_class = rosservice.get_service_class_by_name(saver_service_name)
    saver_srv_client = rospy.ServiceProxy(saver_service_name, saver_srv_class)
    saver_srv_client(saver_data)

    just_debug = False

    for i in range(0, sleep_second):
        rospy.loginfo('S1) wait for %d second now : %d s', sleep_second, i)
        time.sleep(1)

    if just_debug:
        try:
            reset_odom_service_name = '/small_scout_1/reset_odom_to_pose'
            reset_odom_srv_class = rosservice.get_service_class_by_name(
                reset_odom_service_name)
            reset_odom_srv_client = rospy.ServiceProxy(reset_odom_service_name,
                                                       reset_odom_srv_class)
            reset_odom_srv_client(12.0, 4.0, 1.648, 0.0, 0.0, 0.783999)
        except Exception as e:
            print("S1 get pose except Error", e)
            pass
    else:
        srv_enable_robot_position_callback('/small_scout_1', True)

    angle = Float64()
    # angle = math.radians(5)
    angle = math.radians(sensor_pitch_value)
    sensor_pitch.publish(angle)

    # rospy.init_node('turtlebot3_obstacle')
    try:
        rospy.loginfo('S1) Check the obstacle ')
        Obstacle()
        # while 1:
        #     x = 1

    except rospy.ROSInterruptException:
        pass


if __name__ == '__main__':
    main()
